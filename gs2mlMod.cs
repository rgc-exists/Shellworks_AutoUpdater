using UndertaleModLib;
using System;
using System.Net.Http;
using System.Threading.Tasks;
using Newtonsoft.Json.Linq;
using System.Reflection;
using Microsoft.VisualBasic.FileIO;
using System.IO.Compression;
using Newtonsoft.Json;

namespace Shellworks_AutoUpdater;


//CODE PARTIALLY GENERATED BY CHATGPT
//I won't do this on professional projects, but this is just for fun so I figured I'd try it out. :)
public class Shellworks_AutoUpdater
{
    
    public async void Load(int audiogroup, UndertaleData data)
    {
        string modDirectory = Path.Combine(Assembly.GetExecutingAssembly().Location, "..");
        string shellworksModDirectory = Path.Combine(modDirectory, "..", "Shellworks");
        string versionFilePath = Path.Combine(modDirectory, "version.txt");
        string currentVersion = "";
        if(File.Exists(versionFilePath)){
            currentVersion = File.ReadAllText(versionFilePath);
        }

        Console.WriteLine("Checking for new Shellworks updates...");
        if (IsUpdateAvailable(currentVersion))
        {
            Console.WriteLine("A new version is available. Starting download...");
            DownloadLatestRelease(versionFilePath);
        }
        else
        {
            Console.WriteLine("Shellworks is up to date!");
        }
    }



    static bool IsUpdateAvailable(string currentVersion)
    {
        string repoOwner = "rgc-exists";
        string repoName = "Shellworks";
        string apiUrl = $"https://api.github.com/repos/{repoOwner}/{repoName}/releases/latest";

        using (HttpClient client = new HttpClient())
        {
            client.DefaultRequestHeaders.Add("User-Agent", "C# console program");
            client.DefaultRequestHeaders.Add("Accept", "application/vnd.github.v3+json");

            try
            {
                var response = client.GetStringAsync(apiUrl).Result; // Use .Result to wait synchronously
                JObject latestRelease = JObject.Parse(response);
                string latestVersion = latestRelease["tag_name"].ToString();

                // Compare the current version with the latest version
                return !currentVersion.Equals(latestVersion, StringComparison.OrdinalIgnoreCase);
            }
            catch (AggregateException ae)
            {
                Console.WriteLine($"An error occurred while checking if a new shellworks version is available:\n {ae.Flatten().InnerException.Message}");
                return false;
            }
        }
    }

    static void DownloadLatestRelease(string versionFilePath)
    {
        string repoOwner = "rgc-exists";
        string repoName = "Shellworks";
        string apiUrl = $"https://api.github.com/repos/{repoOwner}/{repoName}/releases/latest";

        using (HttpClient client = new HttpClient())
        {
            client.DefaultRequestHeaders.Add("User-Agent", "C# console program");
            client.DefaultRequestHeaders.Add("Accept", "application/vnd.github.v3+json");

            try
            {
                var response = client.GetStringAsync(apiUrl).Result;
                JObject latestRelease = JObject.Parse(response);
                string latestVersion = latestRelease["tag_name"].ToString();

                string downloadUrl = latestRelease["assets"][0]["browser_download_url"].ToString();

                if (!string.IsNullOrEmpty(downloadUrl))
                {
                    Console.WriteLine($"Latest release found. Version: {latestVersion}. Downloading...");
                    
                    string modDirectory = Path.Combine(Assembly.GetExecutingAssembly().Location, "..");
                    string fileName = Path.Combine(modDirectory, "latest.zip");
                    byte[] fileBytes = client.GetByteArrayAsync(downloadUrl).Result;
                    File.WriteAllBytes(fileName, fileBytes); 

                    Console.WriteLine($"File '{fileName}' has been downloaded successfully.");
                    
                    Console.WriteLine("Unzipping...");
                    string unzippedPath = Path.Combine(modDirectory, "latest_unzipped");
                    if(Directory.Exists(unzippedPath)){
                        DeleteDirectoryRecursively(unzippedPath);
                    }
                    ZipFile.ExtractToDirectory(fileName, unzippedPath);

                    string modInfoPath = FindModInfoPath(unzippedPath);
                    if(modInfoPath != ""){
                        Console.WriteLine("Deleting old installation...");
                        string shellworksModDirectory = Path.Combine(modDirectory, "..", "Shellworks");
                        DeleteDirectoryRecursively(shellworksModDirectory);

                        Console.WriteLine("Copying unzipped archive to " + shellworksModDirectory);
                        string modExtractedPath = Path.Combine(modInfoPath, "..");
                        CopyDirectoryRecursively(modExtractedPath, shellworksModDirectory);
                        
                        Console.WriteLine("Updating cached version...");
                        File.WriteAllText(versionFilePath, latestVersion); 

                        Console.WriteLine("Shellworks installation complete.");
                    } else {
                        Console.WriteLine("Could not find the Shellworks/modinfo.json file path in the unzipped archive. Continuing with old version...");
                    }
                }
                else
                {
                    Console.WriteLine("No assets found in the latest release.");
                }
            }
            catch (AggregateException ae)
            {
                // Handle potential exceptions that may occur
                Console.WriteLine($"An error occurred while downloading the new shellworks version:\n{ae.Flatten().InnerException.Message}");
            }
        }
    }

    static void DeleteDirectoryRecursively(string path){
        if(Directory.Exists(path)){
            foreach(string f in Directory.GetFiles(path)){
                File.Delete(f);
            }
            foreach(string d in Directory.GetDirectories(path)){
                DeleteDirectoryRecursively(d);
            }
            Directory.Delete(path);
        }
    }

    static void CopyDirectoryRecursively(string oldPath, string outputPath){
        if(!Directory.Exists(outputPath)){
            Directory.CreateDirectory(outputPath);
        }
        if(Directory.Exists(oldPath)){
            foreach(string f in Directory.GetFiles(oldPath)){
                string newFilePath = Path.Combine(outputPath, Path.GetFileName(f));
                if(File.Exists(newFilePath)){
                    File.Delete(newFilePath);
                }
                File.Copy(f, newFilePath);
            }
            foreach(string d in Directory.GetDirectories(oldPath)){
                CopyDirectoryRecursively(d, Path.Combine(outputPath, Path.GetFileName(d)));
            }
        }
    }


    static string FindModInfoPath(string path){
        List<string> directoriesToSearch = new List<string>{path};
        while(directoriesToSearch.Count > 0){
            string curPath = directoriesToSearch[0];
            Console.WriteLine("Testing " + curPath);
            if(Directory.Exists(curPath)){
                if(Path.GetFileName(curPath) == "Shellworks"){
                    foreach(string f in Directory.GetFiles(curPath)){
                        if(Path.GetFileName(f) == "modinfo.json"){
                            return f;
                        }
                    }
                }
                foreach(string d in Directory.GetDirectories(curPath)){
                    directoriesToSearch.Add(d);
                }
            }
            directoriesToSearch.RemoveAt(0);
        }
        return "";
            
    }
}
